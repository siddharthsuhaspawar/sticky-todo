<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A minimal, elegant sticky todo app">
  <meta name="ai-compatible" content="true">
  <meta name="ai-purpose" content="task management, productivity">
  <title>Sticky ToDo</title>
  
  <!-- Structured Data for AI Agents -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Sticky ToDo",
    "description": "A minimal, elegant todo application with dark/light themes, drag-and-drop, and keyboard shortcuts",
    "url": "https://siddharthsuhaspawar.github.io/sticky-todo/",
    "applicationCategory": "ProductivityApplication",
    "operatingSystem": "Any",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "featureList": [
      "Task management with priorities",
      "Dark and light themes",
      "Drag and drop reordering",
      "Search functionality",
      "Keyboard shortcuts",
      "Local data persistence",
      "AI agent API access"
    ],
    "screenshot": "https://siddharthsuhaspawar.github.io/sticky-todo/screenshots/dark-mode.png",
    "softwareHelp": {
      "@type": "CreativeWork",
      "text": "Press / to add task, Ctrl+K to search, Esc to close"
    }
  }
  </script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --bg: #0c0c0e;
      --surface: #16161a;
      --surface-hover: #1e1e24;
      --border: #2a2a32;
      --text: #f5f5f7;
      --text-secondary: #86868b;
      --text-tertiary: #5a5a60;
      --accent: #0a84ff;
      --accent-hover: #409cff;
      --danger: #ff453a;
      --success: #30d158;
      --warning: #ff9f0a;
      --done-text: #5a5a60;
      --priority-high: #ff453a;
      --priority-medium: #ff9f0a;
      --priority-low: #30d158;
  
      --font-display: Georgia, 'Times New Roman', serif;
      --font-body: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
    }
    
    .light {
      --bg: #f5f5f7;
      --surface: #ffffff;
      --surface-hover: #f0f0f2;
      --border: #d2d2d7;
      --text: #1d1d1f;
      --text-secondary: #86868b;
      --text-tertiary: #a1a1a6;
      --accent: #0071e3;
      --accent-hover: #0077ed;
      --danger: #ff3b30;
      --success: #34c759;
      --warning: #ff9500;
      --done-text: #a1a1a6;
      --priority-high: #ff3b30;
      --priority-medium: #ff9500;
      --priority-low: #34c759;

    }
    
    html { font-size: 16px; }
    
    body {
      font-family: var(--font-body);
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      line-height: 1.5;
      transition: background-color 0.2s, color 0.2s;
    }

    /* Minimal scrollbar styling */
    ::-webkit-scrollbar {
      width: 4px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--text-tertiary);
      border-radius: 2px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--text-secondary);
    }

    /* Firefox */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--text-tertiary) transparent;
    }
    
    .container {
      max-width: 480px;
      margin: 0 auto;
      padding: 40px 24px;
    }
    
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 28px;
    }
    
    .brand {
      display: flex;
      align-items: baseline;
      gap: 8px;
    }
    
    .brand-sticky {
      font-family: var(--font-display);
      font-size: 32px;
      font-weight: 400;
      font-style: italic;
      letter-spacing: -0.01em;
      background: linear-gradient(135deg, var(--text) 0%, var(--text-secondary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .brand-todo {
      font-size: 22px;
      font-weight: 600;
      letter-spacing: -0.02em;
      color: var(--text);
    }
    
    .header-actions {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .icon-button {
      width: 40px;
      height: 40px;
      border: 1px solid var(--border);
      background: var(--surface);
      border-radius: 10px;
      cursor: pointer;
      font-size: 16px;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }
    
    .icon-button:hover {
      background: var(--surface-hover);
      color: var(--text);
    }
    
    /* Color Picker */
    .color-picker-wrapper {
      position: relative;
    }
    
    .color-picker-panel {
      position: absolute;
      top: 48px;
      right: 0;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      min-width: 180px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      opacity: 0;
      visibility: hidden;
      transform: translateY(-8px);
      transition: all 0.2s;
      z-index: 100;
    }
    
    .color-picker-panel.show {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }
    
    .color-picker-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
    }
    
    .color-presets {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-bottom: 12px;
    }
    
    .color-preset {
      width: 32px;
      height: 32px;
      border-radius: 8px;
      border: 2px solid transparent;
      cursor: pointer;
      transition: all 0.15s;
    }
    
    .color-preset:hover {
      transform: scale(1.1);
    }
    
    .color-preset.active {
      border-color: var(--text);
      box-shadow: 0 0 0 2px var(--surface), 0 0 0 4px var(--accent);
    }
    
    .color-custom {
      display: flex;
      align-items: center;
      gap: 8px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }
    
    .color-input-wrapper {
      position: relative;
      flex: 1;
    }
    
    .color-input {
      width: 100%;
      height: 36px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg);
      color: var(--text);
      font-size: 13px;
      padding: 0 10px 0 32px;
      cursor: pointer;
    }
    
    .color-input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .color-preview {
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      width: 16px;
      height: 16px;
      border-radius: 4px;
      background: var(--accent);
      border: 1px solid var(--border);
      pointer-events: none;
    }
    
    .color-native-input {
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
    }
    
    /* Search Bar */
    .search-section {
      display: none;
      gap: 10px;
      margin-bottom: 16px;
      animation: fadeIn 0.2s ease;
    }
    
    .search-section.active {
      display: flex;
    }
    
    .search-input {
      flex: 1;
      padding: 14px 16px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--surface);
      color: var(--text);
      font-family: inherit;
      font-size: 15px;
      outline: none;
      transition: border-color 0.15s, box-shadow 0.15s;
    }
    
    .search-input::placeholder { color: var(--text-tertiary); }
    
    .search-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(10, 132, 255, 0.2);
    }
    
    .search-badge {
      font-size: 12px;
      color: var(--text-tertiary);
      padding: 4px 8px;
      background: var(--surface);
      border-radius: 6px;
      white-space: nowrap;
      display: flex;
      align-items: center;
    }
    
    .input-section {
      display: flex;
      gap: 10px;
      margin-bottom: 16px;
    }
    
    .task-input {
      flex: 1;
      padding: 14px 16px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--surface);
      color: var(--text);
      font-family: inherit;
      font-size: 15px;
      outline: none;
      transition: border-color 0.15s, box-shadow 0.15s;
    }
    
    .task-input::placeholder { color: var(--text-tertiary); }
    
    .task-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(10, 132, 255, 0.2);
    }
    
    .add-button {
      padding: 14px 20px;
      border: none;
      border-radius: 12px;
      background: var(--accent);
      color: #fff;
      font-family: inherit;
      font-size: 20px;
      font-weight: 300;
      cursor: pointer;
      transition: all 0.15s;
      min-width: 52px;
    }
    
    .add-button:hover {
      background: var(--accent-hover);
      transform: translateY(-1px);
    }
    
    .add-button:active { transform: translateY(0); }
    
    /* Priority selector */
    .priority-selector {
      display: flex;
      gap: 8px;
      margin-bottom: 20px;
      padding: 4px;
      background: var(--surface);
      border-radius: 10px;
      border: 1px solid var(--border);
    }
    
    .priority-btn {
      flex: 1;
      padding: 8px 12px;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.15s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    
    .priority-btn.active {
      background: var(--surface-hover);
      color: var(--text);
    }
    
    .priority-btn.high.active { color: var(--priority-high); }
    .priority-btn.medium.active { color: var(--priority-medium); }
    .priority-btn.low.active { color: var(--priority-low); }
    
    .priority-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    
    .priority-dot.high { background: var(--priority-high); }
    .priority-dot.medium { background: var(--priority-medium); }
    .priority-dot.low { background: var(--priority-low); }
    
    /* Filter tabs & progress */
    .controls-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0;
      margin-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    
    .filter-tabs {
      display: flex;
      gap: 4px;
    }
    
    .filter-tab {
      padding: 6px 12px;
      border: none;
      background: transparent;
      color: var(--text-tertiary);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.15s;
    }
    
    .filter-tab:hover { color: var(--text-secondary); }
    .filter-tab.active {
      background: var(--surface);
      color: var(--text);
    }
    
    .progress-section {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .progress-bar {
      width: 60px;
      height: 6px;
      background: var(--surface);
      border-radius: 3px;
      overflow: hidden;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), var(--accent-hover));
      border-radius: 3px;
      transition: width 0.3s ease;
    }
    
    .progress-text {
      font-size: 12px;
      color: var(--text-tertiary);
      min-width: 36px;
      text-align: right;
    }
    
    .stats-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0 0;
      font-size: 13px;
      color: var(--text-secondary);
    }
    
    .stats-text span { color: var(--accent); font-weight: 600; }
    
    .clear-completed {
      background: transparent;
      border: none;
      color: var(--text-tertiary);
      font-size: 13px;
      cursor: pointer;
      padding: 4px 10px;
      border-radius: 6px;
      transition: all 0.15s;
    }
    
    .clear-completed:hover {
      color: var(--danger);
      background: rgba(255, 69, 58, 0.08);
    }
    
    .task-list { 
      display: flex; 
      flex-direction: column; 
      gap: 6px; 
      min-height: 100px;
    }
    
    .task {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 12px;
      border-radius: 10px;
      cursor: grab;
      background: var(--surface);
      border: 1px solid transparent;
      transition: all 0.2s ease;
      animation: slideIn 0.25s ease;
      position: relative;
    }
    
    .task.removing {
      animation: slideOut 0.2s ease forwards;
    }
    
    @keyframes slideIn {
      from { opacity: 0; transform: translateX(-20px); }
      to { opacity: 1; transform: translateX(0); }
    }
    
    @keyframes slideOut {
      from { opacity: 1; transform: translateX(0); }
      to { opacity: 0; transform: translateX(20px); height: 0; padding: 0; margin: 0; }
    }
    
    .task:hover {
      background: var(--surface-hover);
      border-color: var(--border);
      transform: translateX(2px);
    }
    
    .task:active { cursor: grabbing; }
    
    .task.dragging {
      opacity: 0.9;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      border-color: var(--accent);
      transform: scale(1.02);
    }
    
    .task.drag-over { position: relative; }
    
    .task.drag-over::before {
      content: '';
      position: absolute;
      top: -3px;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--accent);
      border-radius: 1px;
    }
    
    /* Priority indicator */
    .priority-indicator {
      width: 4px;
      height: 24px;
      border-radius: 2px;
      flex-shrink: 0;
    }
    
    .priority-indicator.high { background: var(--priority-high); }
    .priority-indicator.medium { background: var(--priority-medium); }
    .priority-indicator.low { background: var(--priority-low); }
    
    .checkbox {
      width: 22px;
      height: 22px;
      border: 2px solid var(--text-tertiary);
      border-radius: 50%;
      cursor: pointer;
      flex-shrink: 0;
      transition: all 0.15s;
      position: relative;
    }
    
    .checkbox:hover { border-color: var(--accent); }
    
    .task.done .checkbox {
      background: var(--success);
      border-color: var(--success);
    }
    
    .checkbox::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      width: 8px;
      height: 8px;
      background: #fff;
      border-radius: 50%;
      transition: transform 0.15s;
    }
    
    .task.done .checkbox::after { transform: translate(-50%, -50%) scale(1); }
    
    .task-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }
    
    .task.pinned {
      border-left: 3px solid var(--accent);
      background: var(--surface-hover);
    }
    
    .pin-button {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
      color: var(--text-tertiary);
      font-size: 14px;
      cursor: pointer;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      opacity: 0.5;
    }
    
    .task:hover .pin-button,
    .pin-button.pinned {
      opacity: 1;
    }
    
    .pin-button:hover {
      background: var(--surface-hover);
      color: var(--accent);
    }
    
    .pin-button.pinned {
      color: var(--accent);
      transform: rotate(-45deg);
    }
    
    .task-text {
      font-size: 15px;
      color: var(--text);
      word-break: break-word;
      cursor: text;
      padding: 2px 4px;
      margin: -2px -4px;
      border-radius: 4px;
      transition: background 0.15s;
    }
    
    .task-text:hover {
      background: var(--surface-hover);
    }
    
    .task-text[contenteditable="true"] {
      background: var(--bg);
      outline: 2px solid var(--accent);
      cursor: text;
    }
    
    .task.done .task-text {
      color: var(--done-text);
      text-decoration: line-through;
    }
    
    .task-actions {
      display: flex;
      align-items: center;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.15s;
    }
    
    .task:hover .task-actions { opacity: 1; }
    
    .action-btn {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
      color: var(--text-tertiary);
      font-size: 14px;
      cursor: pointer;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
    }
    
    .action-btn:hover {
      background: var(--surface-hover);
      color: var(--text);
    }
    
    .action-btn.delete:hover {
      background: rgba(255, 69, 58, 0.1);
      color: var(--danger);
    }
    
    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--text-secondary);
    }
    
    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.4;
    }
    
    .empty-state-text {
      font-size: 15px;
      font-style: italic;
      font-family: Georgia, serif;
      color: var(--text-tertiary);
    }
    
    .footer {
      margin-top: 40px;
      text-align: center;
      font-size: 12px;
      color: var(--text-tertiary);
    }
    
    .footer p { margin-bottom: 6px; }
    
    .footer kbd {
      display: inline-block;
      padding: 2px 6px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 11px;
      margin: 0 2px;
    }
    
    /* Undo Toast */
    .toast-container {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      pointer-events: none;
    }
    
    .toast {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      pointer-events: all;
      animation: toastIn 0.3s ease;
    }
    
    .toast.hiding {
      animation: toastOut 0.3s ease forwards;
    }
    
    @keyframes toastIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes toastOut {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(20px); }
    }
    
    .toast-message {
      font-size: 14px;
      color: var(--text);
    }
    
    .toast-action {
      padding: 6px 12px;
      border: none;
      background: var(--accent);
      color: #fff;
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      border-radius: 6px;
      transition: background 0.15s;
    }
    
    .toast-action:hover { background: var(--accent-hover); }
    
    /* Confetti Canvas */
    #confetti-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 999;
    }
    

    @media (max-width: 520px) {
      .container { padding: 32px 16px; }
      .brand-sticky { font-size: 28px; }
      .brand-todo { font-size: 20px; }
      .task-actions { opacity: 1; }
      .priority-selector { font-size: 12px; }
      .priority-btn { padding: 6px 8px; }
    }

    /* AI Mode Panel */
    .ai-mode-panel {
      position: fixed;
      right: 20px;
      top: 80px;
      width: 380px;
      max-height: calc(100vh - 100px);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      z-index: 200;
      opacity: 0;
      visibility: hidden;
      transform: translateX(20px);
      transition: all 0.3s ease;
      overflow-y: auto;
    }

    .ai-mode-panel.show {
      opacity: 1;
      visibility: visible;
      transform: translateX(0);
    }

    .ai-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }

    .ai-panel-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .ai-panel-close {
      width: 28px;
      height: 28px;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: 6px;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .ai-panel-close:hover {
      background: var(--surface-hover);
      color: var(--text);
    }

    .ai-section {
      margin-bottom: 16px;
    }

    .ai-section-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .ai-command-input {
      width: 100%;
      padding: 12px 14px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--bg);
      color: var(--text);
      font-family: inherit;
      font-size: 14px;
      outline: none;
      margin-bottom: 8px;
    }

    .ai-command-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(10, 132, 255, 0.2);
    }

    .ai-command-input::placeholder {
      color: var(--text-tertiary);
    }

    .ai-suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
    }

    .ai-suggestion {
      padding: 6px 12px;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 16px;
      font-size: 12px;
      color: var(--text-secondary);
      cursor: pointer;
      transition: all 0.15s;
    }

    .ai-suggestion:hover {
      background: var(--surface-hover);
      color: var(--text);
      border-color: var(--accent);
    }

    .ai-output {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 12px;
      color: var(--text-secondary);
      min-height: 80px;
      max-height: 200px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .ai-output.success { color: var(--success); }
    .ai-output.error { color: var(--danger); }

    .ai-api-ref {
      background: var(--bg);
      border-radius: 8px;
      padding: 12px;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 11px;
      color: var(--text-secondary);
    }

    .ai-api-ref code {
      color: var(--accent);
    }

    .ai-toggle-btn {
      position: fixed;
      right: 20px;
      bottom: 20px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: linear-gradient(135deg, var(--accent), var(--accent-hover));
      color: white;
      border: none;
      cursor: pointer;
      font-size: 24px;
      box-shadow: 0 4px 20px rgba(10, 132, 255, 0.5), 0 0 0 4px var(--bg);
      transition: all 0.2s;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .ai-toggle-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 24px rgba(10, 132, 255, 0.5);
    }

    .ai-toggle-btn.active {
      background: var(--danger);
      transform: rotate(45deg);
    }

    @media (max-width: 768px) {
      .ai-mode-panel {
        right: 10px;
        left: 10px;
        width: auto;
        top: auto;
        bottom: 80px;
        max-height: 60vh;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div class="brand">
        <span class="brand-sticky">Sticky</span>
        <span class="brand-todo">ToDo</span>
      </div>
      <div class="header-actions">
        <div class="color-picker-wrapper">
          <button class="icon-button" onclick="app.toggleColorPicker()" title="Accent color" aria-label="Change accent color" id="colorPickerBtn">
            <span id="accent-icon" style="width: 16px; height: 16px; border-radius: 50%; background: var(--accent);"></span>
          </button>
          <div class="color-picker-panel" id="colorPickerPanel">
            <div class="color-picker-title">Accent Color</div>
            <div class="color-presets">
              <div class="color-preset active" data-color="#0a84ff" style="background: #0a84ff" onclick="app.setAccentColor('#0a84ff')"></div>
              <div class="color-preset" data-color="#bf5af2" style="background: #bf5af2" onclick="app.setAccentColor('#bf5af2')"></div>
              <div class="color-preset" data-color="#ff375f" style="background: #ff375f" onclick="app.setAccentColor('#ff375f')"></div>
              <div class="color-preset" data-color="#ff9f0a" style="background: #ff9f0a" onclick="app.setAccentColor('#ff9f0a')"></div>
              <div class="color-preset" data-color="#30d158" style="background: #30d158" onclick="app.setAccentColor('#30d158')"></div>
              <div class="color-preset" data-color="#64d2ff" style="background: #64d2ff" onclick="app.setAccentColor('#64d2ff')"></div>
              <div class="color-preset" data-color="#a1a1a6" style="background: #a1a1a6" onclick="app.setAccentColor('#a1a1a6')"></div>
              <div class="color-preset" data-color="#ffd60a" style="background: #ffd60a" onclick="app.setAccentColor('#ffd60a')"></div>
            </div>
            <div class="color-custom">
              <div class="color-input-wrapper">
                <div class="color-preview" id="customColorPreview"></div>
                <input type="text" class="color-input" id="customColorInput" placeholder="#0a84ff" readonly>
                <input type="color" class="color-native-input" id="nativeColorPicker" onchange="app.setAccentColor(this.value)">
              </div>
            </div>
          </div>
        </div>
        <button class="icon-button" onclick="app.saveScreenshot()" title="Save as PNG" aria-label="Save as PNG">üì∑</button>
        <button class="icon-button" onclick="app.toggleTheme()" title="Toggle theme" aria-label="Toggle theme">
          <span id="theme-icon">‚óê</span>
        </button>
      </div>
    </header>

    <!-- Search Section -->
    <div class="search-section" id="searchSection">
      <input type="text" id="searchInput" class="search-input" placeholder="Search tasks..."
             oninput="app.handleSearch()" autocomplete="off">
      <span class="search-badge" id="searchBadge">0 found</span>
      <button class="icon-button" onclick="app.closeSearch()" title="Close search">√ó</button>
    </div>

    <!-- Input Section -->
    <div class="input-section" id="inputSection">
      <input type="text" id="taskInput" class="task-input" placeholder="What needs to be done?"
             onkeypress="if(event.key==='Enter')app.addTask()" autocomplete="off">
      <button class="add-button" onclick="app.addTask()" aria-label="Add task">+</button>
    </div>

    <!-- Priority Selector -->
    <div class="priority-selector">
      <button class="priority-btn high" onclick="app.setPriority('high')" data-priority="high">
        <span class="priority-dot high"></span> High
      </button>
      <button class="priority-btn medium active" onclick="app.setPriority('medium')" data-priority="medium">
        <span class="priority-dot medium"></span> Medium
      </button>
      <button class="priority-btn low" onclick="app.setPriority('low')" data-priority="low">
        <span class="priority-dot low"></span> Low
      </button>
    </div>

    <!-- Filter Tabs & Progress -->
    <div class="controls-bar">
      <div class="filter-tabs">
        <button class="filter-tab active" onclick="app.setFilter('all')" data-filter="all">All</button>
        <button class="filter-tab" onclick="app.setFilter('active')" data-filter="active">Active</button>
        <button class="filter-tab" onclick="app.setFilter('completed')" data-filter="completed">Done</button>
      </div>
      <div class="progress-section">
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
        <span class="progress-text" id="progressText">0%</span>
      </div>
    </div>

    <div class="task-list" id="taskList"></div>

    <div class="stats-bar" id="statsBar" style="display: none;">
      <span class="stats-text"><span id="pendingCount">0</span> tasks remaining</span>
      <button class="clear-completed" onclick="app.clearCompleted()" id="clearBtn" style="display: none;">
        Clear completed
      </button>
    </div>

    <footer class="footer">
      <p><kbd>/</kbd> add ¬∑ <kbd>Ctrl+K</kbd> search ¬∑ <kbd>Esc</kbd> close</p>
      <p>Click text to edit ¬∑ Drag to reorder</p>
    </footer>
  </div>

  <!-- Undo Toast -->
  <div class="toast-container" id="toastContainer"></div>

  <!-- Confetti Canvas -->
  <canvas id="confetti-canvas"></canvas>

  <script>
    class TodoApp {
      constructor() {
        this.tasks = [];
        this.isDarkMode = true;
        this.isDesktopMode = false;
        this.draggedIndex = null;
        this.draggedElement = null;
        this.currentFilter = 'all';
        this.currentPriority = 'medium';
        this.lastDeleted = null;
        this.hasCelebrated = false;
        this.STORAGE_TASKS = 'sticky-todo-tasks';
        this.STORAGE_THEME = 'sticky-todo-dark';
        this.STORAGE_ACCENT = 'sticky-todo-accent';
        this.currentAccent = '#0a84ff';
        this.searchQuery = '';
        this.isSearchActive = false;
        
        // Pre-bind methods for performance
        this.handleDragStart = this.handleDragStart.bind(this);
        this.handleDragEnd = this.handleDragEnd.bind(this);
        this.handleDragOver = this.handleDragOver.bind(this);
        this.handleDragEnter = this.handleDragEnter.bind(this);
        this.handleDragLeave = this.handleDragLeave.bind(this);
        this.handleDrop = this.handleDrop.bind(this);
      }

      init() {
        if (window.pywebview) {
          this.setupDesktopIntegration();
        } else {
          this.loadFromStorage();
          this.applyTheme();
          this.applyAccentColor();
          this.render();
          this.setupKeyboardShortcuts();
        }
      }

      setupDesktopIntegration() {
        const checkReady = () => {
          if (window.pywebview.api) {
            this.isDesktopMode = true;
            this.loadFromDesktop();
          } else {
            setTimeout(checkReady, 50);
          }
        };
        checkReady();
      }

      async loadFromDesktop() {
        try {
          const [settings, tasksData] = await Promise.all([
            window.pywebview.api.get_settings(),
            window.pywebview.api.get_tasks()
          ]);
          
          this.isDarkMode = settings.dark_mode;
          if (settings.accent_color) this.currentAccent = settings.accent_color;
          this.tasks = tasksData.map(t => ({
            id: t.id,
            text: t.text,
            done: t.done,
            priority: t.priority || 'medium',
            pinned: t.pinned || false,
            createdAt: t.created_at
          }));
          
          this.applyTheme();
          this.applyAccentColor();
          this.render();
          this.setupKeyboardShortcuts();
        } catch (e) {
          this.loadFromStorage();
          this.applyTheme();
          this.applyAccentColor();
          this.render();
          this.setupKeyboardShortcuts();
        }
      }

      loadFromStorage() {
        try {
          const savedTasks = localStorage.getItem(this.STORAGE_TASKS);
          const savedTheme = localStorage.getItem(this.STORAGE_THEME);
          if (savedTasks) {
            this.tasks = JSON.parse(savedTasks);
            // Migrate old tasks
            this.tasks.forEach(t => {
              if (!t.priority) t.priority = 'medium';
              if (t.pinned === undefined) t.pinned = false;
              // Remove legacy dueDate field
              if (t.dueDate) delete t.dueDate;
            });
          }
          if (savedTheme !== null) this.isDarkMode = savedTheme !== 'false';
          
          const savedAccent = localStorage.getItem(this.STORAGE_ACCENT);
          if (savedAccent) this.currentAccent = savedAccent;
        } catch (e) {
          this.tasks = [];
        }
      }

      saveToStorage() {
        if (this.isDesktopMode) return;
        try {
          localStorage.setItem(this.STORAGE_TASKS, JSON.stringify(this.tasks));
          localStorage.setItem(this.STORAGE_THEME, this.isDarkMode.toString());
        } catch (e) {}
      }

      applyTheme() {
        document.body.classList.toggle('light', !this.isDarkMode);
        document.getElementById('theme-icon').textContent = this.isDarkMode ? '‚óê' : '‚óë';
      }

      async toggleTheme() {
        this.isDarkMode = !this.isDarkMode;
        this.applyTheme();
        if (this.isDesktopMode && window.pywebview) {
          await window.pywebview.api.save_theme(this.isDarkMode);
        } else {
          this.saveToStorage();
        }
      }

      setPriority(priority) {
        this.currentPriority = priority;
        document.querySelectorAll('.priority-btn').forEach(btn => {
          btn.classList.toggle('active', btn.dataset.priority === priority);
        });
        document.getElementById('taskInput').focus();
      }

      setFilter(filter) {
        this.currentFilter = filter;
        document.querySelectorAll('.filter-tab').forEach(tab => {
          tab.classList.toggle('active', tab.dataset.filter === filter);
        });
        this.render();
      }

      getFilteredTasks() {
        switch (this.currentFilter) {
          case 'active': return this.tasks.filter(t => !t.done);
          case 'completed': return this.tasks.filter(t => t.done);
          default: return this.tasks;
        }
      }

      async addTask() {
        const input = document.getElementById('taskInput');
        const text = input.value.trim();
        if (!text) return;

        const newTask = {
          id: Date.now().toString(36) + Math.random().toString(36).substr(2),
          text: text,
          done: false,
          priority: this.currentPriority,
          pinned: false,
          createdAt: new Date().toISOString()
        };

        if (this.isDesktopMode && window.pywebview) {
          const result = await window.pywebview.api.add_task(text, newTask.priority);
          if (result.success) {
            this.tasks.unshift({ ...newTask, id: result.task.id });
            input.value = '';
            this.render();
            input.focus();
          }
        } else {
          this.tasks.unshift(newTask);
          input.value = '';
          this.saveToStorage();
          this.render();
          input.focus();
        }
        
        this.hasCelebrated = false;
      }

      // Search functionality
      toggleSearch() {
        this.isSearchActive = !this.isSearchActive;
        const searchSection = document.getElementById('searchSection');
        const inputSection = document.getElementById('inputSection');
        
        if (this.isSearchActive) {
          searchSection.classList.add('active');
          inputSection.style.display = 'none';
          document.getElementById('searchInput').focus();
        } else {
          this.closeSearch();
        }
      }

      closeSearch() {
        this.isSearchActive = false;
        this.searchQuery = '';
        document.getElementById('searchSection').classList.remove('active');
        document.getElementById('inputSection').style.display = 'flex';
        document.getElementById('searchInput').value = '';
        this.handleSearch();
        document.getElementById('taskInput').focus();
      }

      handleSearch() {
        this.searchQuery = document.getElementById('searchInput').value.toLowerCase().trim();
        this.render();
      }

      getFilteredTasks() {
        let tasks = this.tasks;
        
        // Apply status filter
        switch (this.currentFilter) {
          case 'active': tasks = tasks.filter(t => !t.done); break;
          case 'completed': tasks = tasks.filter(t => t.done); break;
        }
        
        // Apply search filter
        if (this.searchQuery) {
          tasks = tasks.filter(t => t.text.toLowerCase().includes(this.searchQuery));
        }
        
        // Sort: pinned first, then by creation date
        tasks = [...tasks].sort((a, b) => {
          if (a.pinned && !b.pinned) return -1;
          if (!a.pinned && b.pinned) return 1;
          return new Date(b.createdAt) - new Date(a.createdAt);
        });
        
        return tasks;
      }

      // Pin functionality
      async togglePin(index) {
        const filtered = this.getFilteredTasks();
        if (index < 0 || index >= filtered.length) return;
        const task = filtered[index];
        const realIndex = this.tasks.findIndex(t => t.id === task.id);
        if (realIndex === -1) return;

        this.tasks[realIndex].pinned = !this.tasks[realIndex].pinned;
        
        if (this.isDesktopMode && window.pywebview) {
          await window.pywebview.api.update_task(this.tasks[realIndex].id, { pinned: this.tasks[realIndex].pinned });
        } else {
          this.saveToStorage();
        }
        this.render();
      }

      toggleColorPicker() {
        const panel = document.getElementById('colorPickerPanel');
        panel.classList.toggle('show');
        
        // Close when clicking outside
        if (panel.classList.contains('show')) {
          setTimeout(() => {
            document.addEventListener('click', this.closeColorPicker);
          }, 10);
        }
      }
      
      closeColorPicker = (e) => {
        const panel = document.getElementById('colorPickerPanel');
        const btn = document.getElementById('colorPickerBtn');
        if (!panel.contains(e.target) && !btn.contains(e.target)) {
          panel.classList.remove('show');
          document.removeEventListener('click', this.closeColorPicker);
        }
      }
      
      setAccentColor(color) {
        this.currentAccent = color;
        this.applyAccentColor();
        
        // Update UI
        document.querySelectorAll('.color-preset').forEach(p => {
          p.classList.toggle('active', p.dataset.color.toLowerCase() === color.toLowerCase());
        });
        
        document.getElementById('customColorInput').value = color;
        document.getElementById('customColorPreview').style.background = color;
        
        // Save
        if (this.isDesktopMode && window.pywebview) {
          window.pywebview.api.save_accent_color(color);
        } else {
          localStorage.setItem(this.STORAGE_ACCENT, color);
        }
      }
      
      applyAccentColor() {
        const color = this.currentAccent;
        const root = document.documentElement;
        
        // Set main accent
        root.style.setProperty('--accent', color);
        
        // Calculate hover color (lighter version)
        const hoverColor = this.lightenColor(color, 20);
        root.style.setProperty('--accent-hover', hoverColor);
        
        // Update input focus shadow
        const style = document.createElement('style');
        style.textContent = `
          .task-input:focus {
            box-shadow: 0 0 0 3px ${this.hexToRgba(color, 0.2)};
          }
          .color-input:focus {
            border-color: ${color};
          }
        `;
        
        // Remove old dynamic styles
        const oldStyle = document.getElementById('dynamic-accent-styles');
        if (oldStyle) oldStyle.remove();
        style.id = 'dynamic-accent-styles';
        document.head.appendChild(style);
      }
      
      lightenColor(hex, percent) {
        const num = parseInt(hex.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = Math.min(255, (num >> 16) + amt);
        const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
        const B = Math.min(255, (num & 0x0000FF) + amt);
        return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
      }
      
      hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      async toggleTask(index) {
        const filtered = this.getFilteredTasks();
        if (index < 0 || index >= filtered.length) return;
        const task = filtered[index];
        const realIndex = this.tasks.findIndex(t => t.id === task.id);
        if (realIndex === -1) return;
        
        if (this.isDesktopMode && window.pywebview) {
          const result = await window.pywebview.api.toggle_task(this.tasks[realIndex].id);
          if (result.success) {
            this.tasks[realIndex].done = result.task.done;
            this.render();
          }
        } else {
          this.tasks[realIndex].done = !this.tasks[realIndex].done;
          this.saveToStorage();
          this.render();
        }
        
        // Check for celebration
        const pending = this.tasks.filter(t => !t.done).length;
        if (pending === 0 && this.tasks.length > 0 && !this.hasCelebrated) {
          this.celebrate();
          this.hasCelebrated = true;
        }
      }

      async deleteTask(index) {
        const filtered = this.getFilteredTasks();
        if (index < 0 || index >= filtered.length) return;
        const task = filtered[index];
        const realIndex = this.tasks.findIndex(t => t.id === task.id);
        if (realIndex === -1) return;
        
        // Store for undo
        this.lastDeleted = { task: this.tasks[realIndex], index: realIndex };
        
        // Animate removal
        const taskEls = document.querySelectorAll('.task');
        if (taskEls[index]) {
          taskEls[index].classList.add('removing');
          await this.delay(200);
        }
        
        if (this.isDesktopMode && window.pywebview) {
          const result = await window.pywebview.api.delete_task(this.tasks[realIndex].id);
          if (result.success) {
            this.tasks.splice(realIndex, 1);
            this.render();
            this.showUndoToast();
          }
        } else {
          this.tasks.splice(realIndex, 1);
          this.saveToStorage();
          this.render();
          this.showUndoToast();
        }
      }

      async undoDelete() {
        if (!this.lastDeleted) return;
        
        const { task, index } = this.lastDeleted;
        this.tasks.splice(index, 0, task);
        this.lastDeleted = null;
        
        if (this.isDesktopMode && window.pywebview) {
          await window.pywebview.api.add_task(task.text);
        } else {
          this.saveToStorage();
        }
        this.render();
      }

      showUndoToast() {
        const container = document.getElementById('toastContainer');
        container.innerHTML = `
          <div class="toast" id="undoToast">
            <span class="toast-message">Task deleted</span>
            <button class="toast-action" onclick="app.undoDelete()">Undo</button>
          </div>
        `;
        
        setTimeout(() => {
          const toast = document.getElementById('undoToast');
          if (toast) {
            toast.classList.add('hiding');
            setTimeout(() => container.innerHTML = '', 300);
          }
        }, 4000);
      }

      async moveTask(fromIndex, toIndex) {
        const filtered = this.getFilteredTasks();
        if (fromIndex === toIndex) return;
        
        const fromTask = filtered[fromIndex];
        const toTask = filtered[toIndex];
        const realFromIndex = this.tasks.findIndex(t => t.id === fromTask.id);
        const realToIndex = this.tasks.findIndex(t => t.id === toTask.id);
        
        const [task] = this.tasks.splice(realFromIndex, 1);
        this.tasks.splice(realToIndex, 0, task);
        
        if (this.isDesktopMode && window.pywebview) {
          await window.pywebview.api.reorder_tasks(this.tasks.map(t => t.id));
        } else {
          this.saveToStorage();
        }
        this.render();
      }

      async clearCompleted() {
        const completedCount = this.tasks.filter(t => t.done).length;
        if (completedCount === 0) return;
        
        if (this.isDesktopMode && window.pywebview) {
          const result = await window.pywebview.api.clear_completed();
          if (result.success) {
            this.tasks = this.tasks.filter(t => !t.done);
            this.render();
          }
        } else {
          this.tasks = this.tasks.filter(t => !t.done);
          this.saveToStorage();
          this.render();
        }
      }

      startEditing(index) {
        const filtered = this.getFilteredTasks();
        if (index < 0 || index >= filtered.length) return;
        const task = filtered[index];
        
        const taskEls = document.querySelectorAll('.task-text');
        if (!taskEls[index]) return;
        
        const el = taskEls[index];
        el.contentEditable = true;
        el.focus();
        
        // Select all text
        const range = document.createRange();
        range.selectNodeContents(el);
        const sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
        
        const saveEdit = () => {
          el.contentEditable = false;
          const newText = el.textContent.trim();
          if (newText && newText !== task.text) {
            const realIndex = this.tasks.findIndex(t => t.id === task.id);
            if (realIndex !== -1) {
              this.tasks[realIndex].text = newText;
              if (this.isDesktopMode && window.pywebview) {
                // Desktop API doesn't have edit, so we update local only
              }
              this.saveToStorage();
              this.render();
            }
          } else if (!newText) {
            this.render(); // Revert if empty
          }
        };
        
        el.addEventListener('blur', saveEdit, { once: true });
        el.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            el.blur();
          } else if (e.key === 'Escape') {
            el.textContent = task.text;
            el.blur();
          }
        }, { once: true });
      }

      celebrate() {
        const canvas = document.getElementById('confetti-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const colors = ['#0a84ff', '#30d158', '#ff9f0a', '#ff453a', '#bf5af2', '#64d2ff'];
        const confetti = [];
        
        for (let i = 0; i < 100; i++) {
          confetti.push({
            x: canvas.width / 2,
            y: canvas.height / 2,
            vx: (Math.random() - 0.5) * 15,
            vy: (Math.random() - 0.5) * 15 - 5,
            color: colors[Math.floor(Math.random() * colors.length)],
            size: Math.random() * 8 + 4,
            rotation: Math.random() * 360,
            rotationSpeed: (Math.random() - 0.5) * 10
          });
        }
        
        let frame = 0;
        const animate = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          confetti.forEach((c, i) => {
            c.x += c.vx;
            c.y += c.vy;
            c.vy += 0.3; // gravity
            c.rotation += c.rotationSpeed;
            c.vx *= 0.99; // air resistance
            
            ctx.save();
            ctx.translate(c.x, c.y);
            ctx.rotate((c.rotation * Math.PI) / 180);
            ctx.fillStyle = c.color;
            ctx.fillRect(-c.size / 2, -c.size / 2, c.size, c.size);
            ctx.restore();
            
            // Remove off-screen confetti
            if (c.y > canvas.height + 50) {
              confetti.splice(i, 1);
            }
          });
          
          frame++;
          if (confetti.length > 0 && frame < 200) {
            requestAnimationFrame(animate);
          } else {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
          }
        };
        
        animate();
      }

      render() {
        const statsBar = document.getElementById('statsBar');
        const pendingCount = document.getElementById('pendingCount');
        const clearBtn = document.getElementById('clearBtn');
        const container = document.getElementById('taskList');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const searchBadge = document.getElementById('searchBadge');
        
        const filtered = this.getFilteredTasks();
        const pending = this.tasks.filter(t => !t.done).length;
        const completed = this.tasks.length - pending;
        
        // Update search badge
        if (searchBadge && this.isSearchActive) {
          searchBadge.textContent = `${filtered.length} found`;
        }
        
        // Update progress
        const progress = this.tasks.length > 0 ? Math.round((completed / this.tasks.length) * 100) : 0;
        progressFill.style.width = `${progress}%`;
        progressText.textContent = `${progress}%`;
        
        if (this.tasks.length === 0) {
          statsBar.style.display = 'none';
          container.innerHTML = `
            <div class="empty-state">
              <div class="empty-state-icon">‚úì</div>
              <div class="empty-state-text">All caught up! Add a task to get started.</div>
            </div>`;
          return;
        }
        
        if (filtered.length === 0) {
          statsBar.style.display = 'flex';
          pendingCount.textContent = pending;
          clearBtn.style.display = completed > 0 ? 'block' : 'none';
          container.innerHTML = `
            <div class="empty-state">
              <div class="empty-state-icon">‚òê</div>
              <div class="empty-state-text">No ${this.currentFilter} tasks${this.searchQuery ? ' match your search' : ''}.</div>
            </div>`;
          return;
        }
        
        statsBar.style.display = 'flex';
        pendingCount.textContent = pending;
        clearBtn.style.display = completed > 0 ? 'block' : 'none';
        
        // Use DocumentFragment for better performance
        const fragment = document.createDocumentFragment();
        
        filtered.forEach((task, index) => {
          const taskEl = document.createElement('div');
          taskEl.className = `task ${task.done ? 'done' : ''} ${task.pinned ? 'pinned' : ''}`;
          taskEl.draggable = true;
          taskEl.dataset.index = index;
          taskEl.dataset.id = task.id;
          
          taskEl.innerHTML = `
            <div class="priority-indicator ${task.priority}"></div>
            <div class="checkbox" onclick="app.toggleTask(${index})" role="checkbox" aria-checked="${task.done}"></div>
            <div class="task-content">
              <span class="task-text" onclick="app.startEditing(${index})">${this.escapeHtml(task.text)}</span>
            </div>
            <div class="task-actions">
              <button class="action-btn pin-button ${task.pinned ? 'pinned' : ''}" onclick="app.togglePin(${index})" title="${task.pinned ? 'Unpin' : 'Pin'}">üìå</button>
              <button class="action-btn" onclick="app.startEditing(${index})" title="Edit">‚úé</button>
              <button class="action-btn delete" onclick="app.deleteTask(${index})" title="Delete">√ó</button>
            </div>
          `;
          
          taskEl.addEventListener('dragstart', this.handleDragStart);
          taskEl.addEventListener('dragend', this.handleDragEnd);
          taskEl.addEventListener('dragover', this.handleDragOver);
          taskEl.addEventListener('dragenter', this.handleDragEnter);
          taskEl.addEventListener('dragleave', this.handleDragLeave);
          taskEl.addEventListener('drop', this.handleDrop);
          
          fragment.appendChild(taskEl);
        });
        
        container.innerHTML = '';
        container.appendChild(fragment);
      }

      handleDragStart(e) {
        this.draggedElement = e.currentTarget;
        this.draggedIndex = parseInt(e.currentTarget.dataset.index);
        e.currentTarget.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
      }

      handleDragEnd(e) {
        e.currentTarget.classList.remove('dragging');
        document.querySelectorAll('.task').forEach(el => el.classList.remove('drag-over'));
        this.draggedIndex = null;
        this.draggedElement = null;
      }

      handleDragOver(e) { e.preventDefault(); }

      handleDragEnter(e) {
        e.preventDefault();
        const target = e.currentTarget;
        if (target && target !== this.draggedElement) {
          document.querySelectorAll('.task').forEach(el => el.classList.remove('drag-over'));
          target.classList.add('drag-over');
        }
      }

      handleDragLeave(e) {
        const target = e.currentTarget;
        if (target && !target.contains(e.relatedTarget)) {
          target.classList.remove('drag-over');
        }
      }

      async handleDrop(e) {
        e.preventDefault();
        const target = e.currentTarget;
        document.querySelectorAll('.task').forEach(el => el.classList.remove('drag-over'));
        if (!target) return;
        const toIndex = parseInt(target.dataset.index);
        if (this.draggedIndex !== null && this.draggedIndex !== toIndex) {
          await this.moveTask(this.draggedIndex, toIndex);
        }
      }

      escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      setupKeyboardShortcuts() {
        document.addEventListener('keydown', (e) => {
          const input = document.getElementById('taskInput');
          const searchInput = document.getElementById('searchInput');
          const modal = document.getElementById('dataModal');
          if (modal.classList.contains('show')) return;
          
          // Ctrl+K or Cmd+K for search
          if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
            e.preventDefault();
            this.toggleSearch();
            return;
          }
          
          // / to focus task input
          if (e.key === '/' && document.activeElement !== input && document.activeElement !== searchInput && !this.isSearchActive) {
            e.preventDefault();
            input.focus();
          }
          
          // Escape to close search or clear input
          if (e.key === 'Escape') {
            if (this.isSearchActive) {
              this.closeSearch();
            } else if (document.activeElement === input) {
              input.value = '';
              input.blur();
            }
          }
        });
      }

      delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      // Screenshot feature - creates a clean summary card
      saveScreenshot() {
        try {
          const isLight = document.body.classList.contains('light');
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Card dimensions
          const width = 600;
          const padding = 50;
          const taskHeight = 45;
          const maxTasks = 8;
          
          // Get tasks to display
          const displayTasks = this.getFilteredTasks().slice(0, maxTasks);
          const hasMore = this.tasks.length > maxTasks;
          const height = 280 + (displayTasks.length * taskHeight) + (hasMore ? 30 : 0);
          
          // Setup canvas (2x for retina)
          canvas.width = width * 2;
          canvas.height = height * 2;
          ctx.scale(2, 2);
          
          // Background with subtle gradient
          const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
          bgGradient.addColorStop(0, isLight ? '#f8f9fa' : '#0c0c0e');
          bgGradient.addColorStop(1, isLight ? '#e9ecef' : '#16161a');
          ctx.fillStyle = bgGradient;
          ctx.fillRect(0, 0, width, height);
          
          // Card background
          ctx.fillStyle = isLight ? '#ffffff' : '#1e1e24';
          this.roundRect(ctx, padding/2, padding/2, width - padding, height - padding, 20);
          ctx.fill();
          
          // Shadow
          ctx.shadowColor = 'rgba(0,0,0,0.15)';
          ctx.shadowBlur = 30;
          ctx.shadowOffsetY = 10;
          ctx.stroke();
          ctx.shadowColor = 'transparent';
          
          let y = padding + 20;
          
          // App title - Sticky with gradient effect, ToDo with regular color
          const stickyText = 'Sticky';
          const todoText = ' ToDo';
          
          // Draw "Sticky" with gradient (matching main UI)
          ctx.font = 'italic 300 32px Georgia, "Times New Roman", serif';
          const stickyWidth = ctx.measureText(stickyText).width;
          const stickyGradient = ctx.createLinearGradient(padding + 20, y - 20, padding + 20 + stickyWidth, y);
          stickyGradient.addColorStop(0, isLight ? '#1d1d1f' : '#f5f5f7');
          stickyGradient.addColorStop(1, isLight ? '#86868b' : '#86868b');
          ctx.fillStyle = stickyGradient;
          ctx.fillText(stickyText, padding + 20, y);
          
          // Draw " ToDo" with regular text color
          ctx.fillStyle = isLight ? '#1d1d1f' : '#f5f5f7';
          ctx.font = '600 24px -apple-system, BlinkMacSystemFont, sans-serif';
          ctx.fillText(todoText, padding + 20 + stickyWidth, y);
          
          // Date on right
          ctx.fillStyle = isLight ? '#86868b' : '#86868b';
          ctx.font = '13px -apple-system, sans-serif';
          const dateStr = new Date().toLocaleDateString('en-US', { 
            weekday: 'short', 
            month: 'short', 
            day: 'numeric' 
          });
          ctx.fillText(dateStr, width - padding - 20 - ctx.measureText(dateStr).width, y);
          
          y += 50;
          
          // Stats row
          const total = this.tasks.length;
          const completed = this.tasks.filter(t => t.done).length;
          const pending = total - completed;
          
          ctx.font = '14px -apple-system, sans-serif';
          ctx.fillStyle = isLight ? '#86868b' : '#86868b';
          ctx.fillText(`${pending} pending ‚Ä¢ ${completed} done`, padding + 20, y);
          
          // Progress bar
          y += 15;
          ctx.fillStyle = isLight ? '#e5e5ea' : '#2c2c34';
          this.roundRect(ctx, padding + 20, y, width - padding * 2 - 40, 6, 3);
          ctx.fill();
          
          if (total > 0) {
            ctx.fillStyle = this.currentAccent;
            this.roundRect(ctx, padding + 20, y, (width - padding * 2 - 40) * (completed / total), 6, 3);
            ctx.fill();
          }
          
          y += 40;
          
          // Divider line
          ctx.strokeStyle = isLight ? '#e5e5ea' : '#2c2c34';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(padding + 20, y - 15);
          ctx.lineTo(width - padding - 20, y - 15);
          ctx.stroke();
          
          // Tasks
          displayTasks.forEach((task, i) => {
            const taskY = y + i * taskHeight;
            
            // Pinned indicator
            if (task.pinned) {
              ctx.fillStyle = this.currentAccent;
              ctx.fillRect(padding + 20, taskY - 8, 3, 26);
            }
            
            // Checkbox
            ctx.strokeStyle = task.done ? '#30d158' : (isLight ? '#d1d1d6' : '#5a5a60');
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(padding + 35, taskY + 5, 8, 0, Math.PI * 2);
            ctx.stroke();
            
            if (task.done) {
              ctx.fillStyle = '#30d158';
              ctx.beginPath();
              ctx.arc(padding + 35, taskY + 5, 8, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = '#fff';
              ctx.font = 'bold 10px sans-serif';
              ctx.fillText('‚úì', padding + 31, taskY + 9);
            }
            
            // Priority dot
            const colors = { high: '#ff453a', medium: '#ff9f0a', low: '#30d158' };
            ctx.fillStyle = colors[task.priority] || '#86868b';
            ctx.beginPath();
            ctx.arc(padding + 65, taskY + 5, 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Task text
            ctx.font = '15px -apple-system, sans-serif';
            ctx.fillStyle = task.done 
              ? (isLight ? '#a1a1a6' : '#5a5a60')
              : (isLight ? '#1d1d1f' : '#f5f5f7');
            
            // Truncate long text
            let text = task.text;
            const maxWidth = width - padding * 2 - 100;
            while (ctx.measureText(text + '...').width > maxWidth && text.length > 3) {
              text = text.slice(0, -1);
            }
            if (text !== task.text) text += '...';
            
            ctx.fillText(text, padding + 80, taskY + 9);
            
            // Strikethrough for done
            if (task.done) {
              const textWidth = ctx.measureText(text).width;
              ctx.strokeStyle = isLight ? '#a1a1a6' : '#5a5a60';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(padding + 80, taskY + 5);
              ctx.lineTo(padding + 80 + textWidth, taskY + 5);
              ctx.stroke();
            }
          });
          
          // "+X more" if needed
          if (hasMore) {
            y += displayTasks.length * taskHeight + 10;
            ctx.fillStyle = isLight ? '#86868b' : '#86868b';
            ctx.font = '13px -apple-system, sans-serif';
            ctx.fillText(`+${this.tasks.length - maxTasks} more tasks...`, padding + 20, y);
          }
          
          // Footer
          y = height - padding - 10;
          ctx.fillStyle = isLight ? '#c7c7cc' : '#5a5a60';
          ctx.font = '11px -apple-system, sans-serif';
          ctx.fillText('Created with Sticky ToDo', padding + 20, y);
          
          // Download
          const link = document.createElement('a');
          link.download = `sticky-todo-${new Date().toISOString().split('T')[0]}.png`;
          link.href = canvas.toDataURL('image/png');
          link.click();
          
          this.showToast('Screenshot saved!');
        } catch (e) {
          console.error('Screenshot error:', e);
          this.showToast('Screenshot failed - please try again');
        }
      }
      
      roundRect(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
      }

      showToast(message) {
        const container = document.getElementById('toastContainer');
        container.innerHTML = `
          <div class="toast" id="infoToast">
            <span class="toast-message">${message}</span>
          </div>
        `;
        
        setTimeout(() => {
          const toast = document.getElementById('infoToast');
          if (toast) {
            toast.classList.add('hiding');
            setTimeout(() => container.innerHTML = '', 300);
          }
        }, 2000);
      }
    }

    // Fast initialization
    const app = new TodoApp();
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        app.init();
        // Process URL parameters after init
        setTimeout(() => {
          const urlResults = TodoAgentAPI.processURLParams();
          if (urlResults.length > 0) {
            console.log('URL parameter actions:', urlResults);
          }
        }, 100);
      });
    } else {
      app.init();
      // Process URL parameters after init
      setTimeout(() => {
        const urlResults = TodoAgentAPI.processURLParams();
        if (urlResults.length > 0) {
          console.log('URL parameter actions:', urlResults);
        }
      }, 100);
    }

    // ============================================
    // AI AGENT API - For programmatic access
    // ============================================
    window.TodoAgentAPI = {
      // App info
      app: {
        name: 'Sticky ToDo',
        version: '1.0.0',
        description: 'A minimal, elegant todo application',
        url: window.location.href
      },

      // Get all tasks
      getTasks: () => {
        return app.tasks.map(t => ({
          id: t.id,
          text: t.text,
          done: t.done,
          priority: t.priority,
          pinned: t.pinned,
          createdAt: t.createdAt
        }));
      },

      // Get pending tasks only
      getPendingTasks: () => {
        return app.tasks.filter(t => !t.done).map(t => ({
          id: t.id,
          text: t.text,
          priority: t.priority,
          pinned: t.pinned
        }));
      },

      // Get completed tasks only
      getCompletedTasks: () => {
        return app.tasks.filter(t => t.done).map(t => ({
          id: t.id,
          text: t.text,
          completedAt: new Date().toISOString()
        }));
      },

      // Add a new task
      addTask: (text, priority = 'medium') => {
        if (!text || typeof text !== 'string') {
          return { success: false, error: 'Task text is required' };
        }
        document.getElementById('taskInput').value = text;
        app.currentPriority = priority;
        app.addTask();
        return { success: true, message: `Added task: "${text}"` };
      },

      // Mark task as complete/incomplete by index
      toggleTask: (index) => {
        const tasks = app.getFilteredTasks();
        if (index < 0 || index >= tasks.length) {
          return { success: false, error: 'Invalid task index' };
        }
        app.toggleTask(index);
        return { success: true, message: `Toggled task at index ${index}` };
      },

      // Delete task by index
      deleteTask: (index) => {
        const tasks = app.getFilteredTasks();
        if (index < 0 || index >= tasks.length) {
          return { success: false, error: 'Invalid task index' };
        }
        app.deleteTask(index);
        return { success: true, message: `Deleted task at index ${index}` };
      },

      // Search tasks
      search: (query) => {
        app.searchQuery = query.toLowerCase();
        app.render();
        const results = app.getFilteredTasks();
        return {
          query,
          count: results.length,
          tasks: results.map(t => ({ id: t.id, text: t.text, done: t.done }))
        };
      },

      // Clear search
      clearSearch: () => {
        app.closeSearch();
        return { success: true, message: 'Search cleared' };
      },

      // Set filter
      setFilter: (filter) => {
        if (!['all', 'active', 'completed'].includes(filter)) {
          return { success: false, error: 'Filter must be: all, active, or completed' };
        }
        app.setFilter(filter);
        return { success: true, filter };
      },

      // Clear all completed tasks
      clearCompleted: () => {
        const count = app.tasks.filter(t => t.done).length;
        app.clearCompleted();
        return { success: true, message: `Cleared ${count} completed tasks` };
      },

      // Toggle theme
      toggleTheme: () => {
        app.toggleTheme();
        return { success: true, darkMode: app.isDarkMode };
      },

      // Export all data
      export: () => {
        return {
          tasks: app.tasks,
          settings: {
            darkMode: app.isDarkMode,
            accentColor: app.currentAccent,
            currentFilter: app.currentFilter
          },
          exportedAt: new Date().toISOString()
        };
      },

      // Import data (replaces all tasks)
      import: (data) => {
        try {
          if (data.tasks && Array.isArray(data.tasks)) {
            app.tasks = data.tasks;
            app.saveToStorage();
            app.render();
            return { success: true, message: `Imported ${data.tasks.length} tasks` };
          }
          return { success: false, error: 'Invalid data format' };
        } catch (e) {
          return { success: false, error: e.message };
        }
      },

      // Get stats
      getStats: () => {
        const total = app.tasks.length;
        const completed = app.tasks.filter(t => t.done).length;
        const pending = total - completed;
        const highPriority = app.tasks.filter(t => t.priority === 'high' && !t.done).length;
        const mediumPriority = app.tasks.filter(t => t.priority === 'medium' && !t.done).length;
        const lowPriority = app.tasks.filter(t => t.priority === 'low' && !t.done).length;
        return { 
          total, 
          completed, 
          pending, 
          highPriority,
          mediumPriority,
          lowPriority,
          completionRate: total > 0 ? Math.round((completed/total)*100) : 0,
          generatedAt: new Date().toISOString()
        };
      },

      // ===== BATCH OPERATIONS (Extremely useful for AI agents) =====
      
      // Add multiple tasks at once
      addTasks: (tasks) => {
        if (!Array.isArray(tasks)) {
          return { success: false, error: 'Expected array of tasks' };
        }
        const added = [];
        tasks.forEach(task => {
          if (typeof task === 'string') {
            document.getElementById('taskInput').value = task;
            app.currentPriority = 'medium';
            app.addTask();
            added.push(task);
          } else if (task.text) {
            document.getElementById('taskInput').value = task.text;
            app.currentPriority = task.priority || 'medium';
            app.addTask();
            added.push(task.text);
          }
        });
        return { success: true, added: added.length, tasks: added };
      },

      // Update multiple tasks at once
      updateTasks: (updates) => {
        if (!Array.isArray(updates)) {
          return { success: false, error: 'Expected array of updates' };
        }
        let updated = 0;
        updates.forEach(update => {
          if (update.index !== undefined && update.changes) {
            const tasks = app.getFilteredTasks();
            if (update.index >= 0 && update.index < tasks.length) {
              const task = tasks[update.index];
              const realIndex = app.tasks.findIndex(t => t.id === task.id);
              if (realIndex !== -1) {
                Object.assign(app.tasks[realIndex], update.changes);
                updated++;
              }
            }
          }
        });
        app.saveToStorage();
        app.render();
        return { success: true, updated };
      },

      // Delete multiple tasks by indices
      deleteTasks: (indices) => {
        if (!Array.isArray(indices)) {
          return { success: false, error: 'Expected array of indices' };
        }
        // Sort in descending order to delete from end first
        const sorted = [...indices].sort((a, b) => b - a);
        let deleted = 0;
        sorted.forEach(index => {
          const result = TodoAgentAPI.deleteTask(index);
          if (result.success) deleted++;
        });
        return { success: true, deleted };
      },

      // ===== ADVANCED SEARCH & FILTER =====
      
      // Find tasks by multiple criteria
      findTasks: (criteria) => {
        let results = app.tasks;
        if (criteria.text) {
          results = results.filter(t => t.text.toLowerCase().includes(criteria.text.toLowerCase()));
        }
        if (criteria.priority) {
          results = results.filter(t => t.priority === criteria.priority);
        }
        if (criteria.done !== undefined) {
          results = results.filter(t => t.done === criteria.done);
        }
        if (criteria.pinned !== undefined) {
          results = results.filter(t => t.pinned === criteria.pinned);
        }
        return {
          count: results.length,
          tasks: results.map((t, idx) => ({ index: idx, ...t }))
        };
      },

      // Sort tasks
      sortTasks: (by = 'createdAt', order = 'desc') => {
        const sortFn = (a, b) => {
          let comparison = 0;
          if (by === 'priority') {
            const pMap = { high: 3, medium: 2, low: 1 };
            comparison = pMap[a.priority] - pMap[b.priority];
          } else if (by === 'text') {
            comparison = a.text.localeCompare(b.text);
          } else if (by === 'createdAt') {
            comparison = new Date(a.createdAt) - new Date(b.createdAt);
          }
          return order === 'desc' ? -comparison : comparison;
        };
        app.tasks.sort(sortFn);
        app.saveToStorage();
        app.render();
        return { success: true, sortedBy: by, order };
      },

      // ===== DATA EXCHANGE FORMATS =====
      
      // Export as markdown (human-readable)
      exportMarkdown: () => {
        const pending = app.tasks.filter(t => !t.done);
        const completed = app.tasks.filter(t => t.done);
        let md = `# Sticky ToDo Export\n\nGenerated: ${new Date().toLocaleString()}\n\n`;
        md += `## Pending Tasks (${pending.length})\n\n`;
        pending.forEach(t => {
          const prio = t.priority === 'high' ? 'üî¥' : t.priority === 'medium' ? 'üü°' : 'üü¢';
          md += `- [ ] ${prio} ${t.text}\n`;
        });
        md += `\n## Completed Tasks (${completed.length})\n\n`;
        completed.forEach(t => {
          md += `- [x] ${t.text}\n`;
        });
        return { success: true, markdown: md };
      },

      // Export as CSV (spreadsheet-friendly)
      exportCSV: () => {
        const headers = ['id', 'text', 'done', 'priority', 'pinned', 'createdAt'];
        const rows = app.tasks.map(t => [
          t.id,
          `"${t.text.replace(/"/g, '""')}"`,
          t.done,
          t.priority,
          t.pinned,
          t.createdAt
        ]);
        const csv = [headers.join(','), ...rows.map(r => r.join(','))].join('\n');
        return { success: true, csv };
      },

      // Import from various formats
      importFromText: (text) => {
        const lines = text.split('\n').filter(l => l.trim());
        const tasks = [];
        lines.forEach(line => {
          // Match - [ ] or - [x] markdown style
          const match = line.match(/^- \[([ x])\] (?:üî¥|üü°|üü¢|high:|medium:|low:)?\s*(.+)$/i);
          if (match) {
            tasks.push({
              text: match[2].trim(),
              done: match[1] === 'x',
              priority: line.includes('üî¥') || line.includes('high:') ? 'high' :
                       line.includes('üü°') || line.includes('medium:') ? 'medium' : 'low'
            });
          } else if (line.trim()) {
            // Plain text line
            tasks.push({ text: line.trim(), done: false, priority: 'medium' });
          }
        });
        return TodoAgentAPI.addTasks(tasks);
      },

      // ===== TASK INTELLIGENCE =====
      
      // Auto-detect priority from text
      suggestPriority: (text) => {
        const lowWords = ['later', 'someday', 'maybe', 'low', 'whenever'];
        const highWords = ['urgent', 'asap', 'important', 'critical', 'deadline', 'today', 'now'];
        const t = text.toLowerCase();
        if (highWords.some(w => t.includes(w))) return 'high';
        if (lowWords.some(w => t.includes(w))) return 'low';
        return 'medium';
      },

      // Smart add with auto-priority
      smartAdd: (text) => {
        const priority = TodoAgentAPI.suggestPriority(text);
        return TodoAgentAPI.addTask(text, priority);
      },

      // Get tasks due today (placeholder for future due date feature)
      getTodaysTasks: () => {
        return TodoAgentAPI.getPendingTasks();
      },

      // ===== URL PARAMETER ACTIONS =====
      // Usage: ?add=Buy+milk&priority=high
      processURLParams: () => {
        const params = new URLSearchParams(window.location.search);
        const results = [];
        
        if (params.has('add')) {
          const text = params.get('add');
          const priority = params.get('priority') || 'medium';
          results.push(TodoAgentAPI.addTask(text, priority));
        }
        
        if (params.has('search')) {
          results.push(TodoAgentAPI.search(params.get('search')));
        }
        
        if (params.has('filter')) {
          results.push(TodoAgentAPI.setFilter(params.get('filter')));
        }
        
        if (params.has('theme')) {
          const theme = params.get('theme');
          if ((theme === 'dark' && !app.isDarkMode) || (theme === 'light' && app.isDarkMode)) {
            app.toggleTheme();
            results.push({ success: true, theme });
          }
        }
        
        // Clear URL params after processing
        if (results.length > 0) {
          window.history.replaceState({}, '', window.location.pathname);
        }
        
        return results;
      },

      // ===== POSTMESSAGE API (for iframe/embed integration) =====
      // Usage: parent.postMessage({action: 'addTask', text: 'Buy milk'}, '*')
      initPostMessage: () => {
        window.addEventListener('message', (event) => {
          if (event.data && event.data.action) {
            const { action, ...params } = event.data;
            let result;
            switch(action) {
              case 'addTask':
                result = TodoAgentAPI.addTask(params.text, params.priority);
                break;
              case 'getTasks':
                result = TodoAgentAPI.getTasks();
                break;
              case 'getStats':
                result = TodoAgentAPI.getStats();
                break;
              case 'export':
                result = TodoAgentAPI.export();
                break;
              default:
                result = { error: 'Unknown action' };
            }
            // Send response back
            if (event.source) {
              event.source.postMessage({ action, result, id: event.data.id }, event.origin);
            }
          }
        });
        return { success: true, message: 'PostMessage API initialized' };
      },

      // Natural language command processor
      command: (input) => {
        return window.AICommandProcessor.process(input);
      },

      // Help
      help: () => {
        return `
Sticky ToDo - AI Agent API
==========================

BASIC OPERATIONS:
  getTasks()              - Get all tasks
  getPendingTasks()       - Get incomplete tasks
  getCompletedTasks()     - Get completed tasks
  addTask(text, priority) - Add new task (priority: high/medium/low)
  smartAdd(text)          - Add with auto-detected priority
  toggleTask(index)       - Toggle completion by index
  deleteTask(index)       - Delete task by index

BATCH OPERATIONS:
  addTasks([{text, priority}, ...])  - Add multiple tasks
  updateTasks([{index, changes}])    - Update multiple tasks
  deleteTasks([index1, index2])      - Delete multiple tasks by indices

SEARCH & FILTER:
  search(query)                  - Search tasks by text
  findTasks({text, priority, done, pinned}) - Advanced search with criteria
  clearSearch()                  - Clear search results
  setFilter(filter)              - Set filter (all/active/completed)
  sortTasks(by, order)           - Sort by: priority/text/createdAt

DATA EXCHANGE:
  export()                       - Export as JSON
  exportMarkdown()               - Export as Markdown
  exportCSV()                    - Export as CSV
  import(data)                   - Import from JSON
  importFromText(text)           - Import from Markdown/text

INTELLIGENCE:
  command(text)                  - Natural language command
  suggestPriority(text)          - Auto-detect priority from text
  getStats()                     - Get task statistics

UTILITY:
  toggleTheme()                  - Switch dark/light mode
  clearCompleted()               - Remove all completed tasks
  processURLParams()             - Process ?add=...&priority=... params
  initPostMessage()              - Enable iframe communication
  help()                         - Show this help

NATURAL LANGUAGE EXAMPLES:
  TodoAgentAPI.command("add buy groceries")
  TodoAgentAPI.command("add high priority call mom")
  TodoAgentAPI.command("complete task 1")
  TodoAgentAPI.command("search meeting")
  TodoAgentAPI.command("show completed")
  TodoAgentAPI.command("stats")

API EXAMPLES:
  TodoAgentAPI.addTask("Buy groceries", "high")
  TodoAgentAPI.smartAdd("URGENT: Submit report")
  TodoAgentAPI.addTasks(["Task 1", "Task 2", {text: "Task 3", priority: "high"}])
  TodoAgentAPI.findTasks({priority: "high", done: false})
  TodoAgentAPI.exportMarkdown()

URL PARAMETERS:
  ?add=Buy+milk&priority=high    - Auto-add task on load
  ?search=meeting                - Auto-search on load
  ?filter=completed              - Auto-filter on load
  ?theme=dark                    - Auto-set theme
        `.trim();
      }
    };

    // ============================================
    // NATURAL LANGUAGE COMMAND PROCESSOR
    // ============================================
    window.AICommandProcessor = {
      process: (input) => {
        const text = input.toLowerCase().trim();
        
        // Add task patterns
        if (text.match(/^(add|create|new)\s+/)) {
          const priorityMatch = text.match(/\b(high|medium|low)\s+priority\b/);
          const priority = priorityMatch ? priorityMatch[1] : 'medium';
          const taskText = input.replace(/^(add|create|new)\s+/i, '').replace(/\b(high|medium|low)\s+priority\b/i, '').trim();
          if (taskText) {
            return TodoAgentAPI.addTask(taskText, priority);
          }
        }
        
        // Complete task patterns
        if (text.match(/^(complete|finish|done|check off)\s+/)) {
          const taskMatch = text.match(/(?:complete|finish|done|check off)\s+(?:task\s+)?(\d+|first|last)/);
          if (taskMatch) {
            let index = -1;
            if (taskMatch[1] === 'first') index = 0;
            else if (taskMatch[1] === 'last') index = TodoAgentAPI.getPendingTasks().length - 1;
            else index = parseInt(taskMatch[1]) - 1;
            return TodoAgentAPI.toggleTask(index);
          }
        }
        
        // Delete task patterns
        if (text.match(/^(delete|remove)\s+/)) {
          const taskMatch = text.match(/(?:delete|remove)\s+(?:task\s+)?(\d+|first|last)/);
          if (taskMatch) {
            let index = -1;
            if (taskMatch[1] === 'first') index = 0;
            else if (taskMatch[1] === 'last') index = app.tasks.length - 1;
            else index = parseInt(taskMatch[1]) - 1;
            return TodoAgentAPI.deleteTask(index);
          }
        }
        
        // Search patterns
        if (text.match(/^(search|find|look for)\s+/)) {
          const query = input.replace(/^(search|find|look for)\s+/i, '').trim();
          return TodoAgentAPI.search(query);
        }
        
        // Show/filter patterns
        if (text.match(/^(show|display|list)\s+/)) {
          if (text.includes('completed') || text.includes('done')) {
            return TodoAgentAPI.setFilter('completed');
          }
          if (text.includes('active') || text.includes('pending') || text.includes('todo')) {
            return TodoAgentAPI.setFilter('active');
          }
          if (text.includes('all')) {
            return TodoAgentAPI.setFilter('all');
          }
        }
        
        // Clear completed
        if (text.match(/clear\s+(all\s+)?completed/)) {
          return TodoAgentAPI.clearCompleted();
        }
        
        // Stats
        if (text.match(/^(stats|status|progress|how many)/)) {
          return { success: true, stats: TodoAgentAPI.getStats() };
        }
        
        // Help
        if (text.match(/^(help|what can you do|commands)/)) {
          return { success: true, message: TodoAgentAPI.help() };
        }
        
        return { success: false, error: 'Unknown command. Try: "add Buy milk", "complete task 1", "search meeting", or "help"' };
      }
    };

    // ============================================
    // AI MODE UI CONTROLLER
    // ============================================
    window.AIMode = {
      isOpen: false,
      
      toggle: () => {
        const panel = document.getElementById('aiModePanel');
        const btn = document.getElementById('aiToggleBtn');
        window.AIMode.isOpen = !window.AIMode.isOpen;
        
        if (window.AIMode.isOpen) {
          panel.classList.add('show');
          btn.classList.add('active');
          document.getElementById('aiCommandInput').focus();
        } else {
          panel.classList.remove('show');
          btn.classList.remove('active');
        }
      },
      
      executeCommand: () => {
        const input = document.getElementById('aiCommandInput');
        const output = document.getElementById('aiOutput');
        const command = input.value.trim();
        
        if (!command) return;
        
        output.textContent = 'Processing...';
        output.className = 'ai-output';
        
        // Process the command
        const result = window.AICommandProcessor.process(command);
        
        // Display result
        if (result.success) {
          output.className = 'ai-output success';
          if (result.stats) {
            output.textContent = `üìä Stats:\nTotal: ${result.stats.total}\nCompleted: ${result.stats.completed}\nPending: ${result.stats.pending}\nHigh Priority: ${result.stats.highPriority}\nCompletion Rate: ${result.stats.completionRate}%`;
          } else if (result.tasks) {
            output.textContent = `üîç Found ${result.count} task(s):\n${result.tasks.map((t, i) => `${i+1}. [${t.done ? '‚úì' : ' '}] ${t.text}`).join('\n')}`;
          } else {
            output.textContent = `‚úì ${result.message || 'Command executed successfully'}`;
          }
        } else {
          output.className = 'ai-output error';
          output.textContent = `‚úó ${result.error || 'Command failed'}`;
        }
        
        input.value = '';
      },
      
      runApiCommand: (cmd) => {
        const output = document.getElementById('aiOutput');
        output.textContent = 'Running: ' + cmd + '\n\n';
        output.className = 'ai-output';
        
        try {
          // eslint-disable-next-line no-eval
          const result = eval(cmd);
          output.textContent += JSON.stringify(result, null, 2);
          output.className = 'ai-output success';
        } catch (e) {
          output.textContent += 'Error: ' + e.message;
          output.className = 'ai-output error';
        }
      }
    };

    // Log welcome message for AI agents
    console.log('%cü§ñ Sticky ToDo - AI Agent API Ready', 'color: #0a84ff; font-size: 14px; font-weight: bold;');
    console.log('%cType TodoAgentAPI.help() to see available commands', 'color: #86868b; font-size: 12px;');
    console.log('%cOr click the ü§ñ button to open AI Mode UI', 'color: #86868b; font-size: 12px;');
  </script>

  <!-- AI Mode Panel (Human-friendly interface for AI features) -->
  <div class="ai-mode-panel" id="aiModePanel">
    <div class="ai-panel-header">
      <div class="ai-panel-title">
        <span>ü§ñ</span>
        <span>AI Assistant</span>
      </div>
      <button class="ai-panel-close" onclick="AIMode.toggle()">√ó</button>
    </div>
    
    <div class="ai-section">
      <div class="ai-section-title">Natural Language Commands</div>
      <input 
        type="text" 
        class="ai-command-input" 
        id="aiCommandInput"
        placeholder="Try: 'add high priority call mom' or 'show completed'"
        onkeydown="if(event.key==='Enter')AIMode.executeCommand()"
      >
      <div class="ai-suggestions">
        <span class="ai-suggestion" onclick="document.getElementById('aiCommandInput').value='add buy groceries';AIMode.executeCommand()">+ buy groceries</span>
        <span class="ai-suggestion" onclick="document.getElementById('aiCommandInput').value='complete task 1';AIMode.executeCommand()">‚úì complete #1</span>
        <span class="ai-suggestion" onclick="document.getElementById('aiCommandInput').value='search meeting';AIMode.executeCommand()">üîç search</span>
        <span class="ai-suggestion" onclick="document.getElementById('aiCommandInput').value='stats';AIMode.executeCommand()">üìä stats</span>
      </div>
    </div>
    
    <div class="ai-section">
      <div class="ai-section-title">Result</div>
      <div class="ai-output" id="aiOutput">Enter a command above or click a suggestion...</div>
    </div>
    
    <div class="ai-section">
      <div class="ai-section-title">Quick API Reference</div>
      <div class="ai-api-ref">
        <code>TodoAgentAPI.addTask("text", "priority")</code><br>
        <code>TodoAgentAPI.getPendingTasks()</code><br>
        <code>TodoAgentAPI.toggleTask(index)</code><br>
        <code>TodoAgentAPI.search("query")</code><br>
        <code>TodoAgentAPI.getStats()</code>
      </div>
    </div>
  </div>

  <!-- AI Toggle Button -->
  <button class="ai-toggle-btn" id="aiToggleBtn" onclick="AIMode.toggle()" title="Open AI Assistant">
    ü§ñ
  </button>
</body>
</html>
